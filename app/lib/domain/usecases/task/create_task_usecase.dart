import 'package:dartz/dartz.dart';
import '../../../core/errors/failures.dart';
import '../../entities/task_entity.dart';
import '../../repositories/task_repository.dart';

/// Use case for creating a new task
class CreateTaskUseCase {
  final TaskRepository repository;

  CreateTaskUseCase(this.repository);

  /// Execute the use case
  ///
  /// Creates a new task with validation
  /// Automatically assigns the next order number
  /// Returns Right(TaskEntity) on success
  /// Returns Left(Failure) on error
  Future<Either<Failure, TaskEntity>> call({
    required String userId,
    required String goalId,
    required String title,
    String description = '',
    DateTime? dueDate,
    int priority = 3,
    String? transactionId,
  }) async {
    // Validate title
    if (title.trim().isEmpty) {
      return Left(
        ValidationFailure(message: 'O título da tarefa é obrigatório'),
      );
    }

    if (title.trim().length > 100) {
      return Left(
        ValidationFailure(
          message: 'O título não pode ter mais de 100 caracteres',
        ),
      );
    }

    // Validate priority
    if (priority < 1 || priority > 5) {
      return Left(
        ValidationFailure(message: 'A prioridade deve estar entre 1 e 5'),
      );
    }

    // Get existing tasks to calculate next order
    final existingTasksResult = await repository.getTasksByGoal(goalId, userId);
    int nextOrder = 0;

    existingTasksResult.fold(
      (failure) {
        // If we can't get tasks, start with order 0
        nextOrder = 0;
      },
      (tasks) {
        // Find the maximum order and add 1
        if (tasks.isNotEmpty) {
          nextOrder = tasks.map((t) => t.order).reduce((a, b) => a > b ? a : b) + 1;
        }
      },
    );

    // Create task entity
    final task = TaskEntity(
      id: '', // Will be generated by Firestore
      userId: userId,
      goalId: goalId,
      title: title.trim(),
      description: description.trim(),
      isCompleted: false,
      transactionId: transactionId,
      dueDate: dueDate,
      priority: priority,
      order: nextOrder,
      createdAt: DateTime.now(),
    );

    return await repository.createTask(task);
  }
}
